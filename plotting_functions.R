# Copyright (C) 2021 György Barabás
# This program comes with ABSOLUTELY NO WARRANTY. This is free software, and
# you are welcome to redistribute it under certain conditions. for details,
# see the GNU General Public License Agreement (in the file COPYING.txt).


require(tidyverse) # manipulating and visualizing data
require(ggpmisc) # adding statistics to plots


# filter dataset for a given trophic level
# Input
# - dat: a data frame like the one generated by ecoevo_main.R
# - level: whether to filter for "resource" or "consumer" species (or "all")
trophic_level <- function(dat, level="resource") {
  if (level=="consumer") { # if we want just consumer species:
    return(filter(dat, tl=="C")) # return filtered data for consumer species
  } else if (level=="all") { # if we want to consider all species together:
    return(dat) # return unfiltered data
  } else { # in all other cases, we assume we want only the resource species:
    return(filter(dat, tl=="R")) # return filtered data for resource species
  }
}


# plot beta diversity (gamma richness divided by alpha richness) over time,
# for each model setup and parameterization
# Input
# - dat: a data frame like the one generated by ecoevo_main.R
# - level: whether plot is for "resource" or "consumer" species (or "all")
# Output
# - a ggplot2 figure
plot_betadiv <- function(dat, level="resource") {
  dat <- trophic_level(dat, level)
  alpha <- dat %>% # obtain local (alpha) diversity
    group_by(parameterization, model, time, patch, replicate) %>%
    summarise(richness=sum(1*(n>1e-6)), .groups="drop_last") %>%
    summarise(meanrich=mean(richness), .groups="drop_last") %>%
    summarise(localrich=mean(meanrich), .groups="drop")
  gamma <- dat %>% # obtain global (gamma) diversity
    mutate(presence=(n!=0)*1) %>%
    group_by(time, parameterization, model, replicate, species) %>%
    summarise(presence=(sum(presence)!=0)*1, .groups="drop_last") %>%
    summarise(rich=sum(presence), .groups="drop_last") %>%
    summarise(globalrich=mean(rich), .groups="drop")
  beta <- left_join(gamma, alpha, by=c("time", "model", "parameterization")) %>%
    mutate(beta_diversity=globalrich/localrich) # obtain beta diversity
  ggplot(beta) +
    geom_point(aes(x=time, y=beta_diversity),
               colour="#0072B2", shape=19, size=1, alpha=0.7) +
    geom_line(aes(x=time, y=beta_diversity),
              colour="#0072B2", linetype="dashed", alpha=0.5) +
    geom_vline(xintercept=300, linetype="dotted") +
    scale_x_continuous(name="time") +
    scale_y_continuous(name="beta diversity") +
    facet_grid(parameterization~model) +
    theme_bw() +
    theme(legend.position="bottom") %>%
    return()
}

# plot the distribution of local species richnesses over time, for each
# model setup and parameterization
# Input
# - dat: a data frame like the one generated by ecoevo_main.R
# - level: whether plot is for "resource" or "consumer" species (or "all")
# Output
# - a ggplot2 figure
plot_diversity <- function(dat, level="resource") {
    trophic_level(dat, level) %>%
    # for each of these variables:
    group_by(time, parameterization, model, patch, replicate) %>%
    # obtain no of species such that their density is over the threshold of 1e-6
    summarise(H=sum(1*(n>1e-6)), .groups="drop_last") %>%
    # now average these results over replicates:
    summarise(meanH=mean(H), .groups="drop_last") %>%
    # and finally, obtain the mean and standard deviation across the L patches:
    summarise(mH=mean(meanH), sH=sd(meanH), .groups="drop") %>%
    ggplot() + # start plotting
    # points for the mean richness at each point in time:
    geom_point(aes(x=time,y=mH), colour="#0072B2", shape=19, size=1, alpha=0.7) +
    # connect them by a light dashed line (for visual aid):
    geom_line(aes(x=time,y=mH), colour="#0072B2", linetype="dashed", alpha=0.5) +
    # show plus/minus 1-sigma region around the mean:
    geom_ribbon(aes(x=time, ymin=mH-sH, ymax=mH+sH),
                colour=NA, fill="#0072B2", alpha=0.3) +
    # vertical dotted line to show where climate change ends in time:
    geom_vline(xintercept=300, linetype="dotted") +
    scale_x_continuous(name="time") +
    scale_y_continuous(name="species richness") +
    facet_grid(parameterization~model) +
    theme_bw() +
    theme(legend.position="bottom") %>%
    return()
}

# plot the Jaccard distance of regional communities from their state at the
# onset of climate change over time, for each model setup and parameterization
# Input
# - dat: a data frame like the one generated by ecoevo_main.R
# - level: whether plot is for "resource" or "consumer" species (or "all")
# Output
# - a ggplot2 figure
plot_jaccard <- function(dat, level="resource") {
  # new column "presence" representing the species present in every patch in
  # binary: if species are represented by 01111111 (all species present in
  # that patch except the first species), this "binary presence" will be 127
  dat <- dat %>%
    # filter for trophic level:
    trophic_level(level) %>%
    # presence=1 if species' density > than a threshold of 1e-6; otherwise 0
    mutate(presence=(n>1e-6)*1) %>%
    # for all parameters below:
    group_by(time, species, replicate, parameterization, model, region) %>%
    # get total number of persisting species:
    summarise(pres=(sum(presence)>0)*1, .groups="drop") %>%
    arrange(time, parameterization, model, replicate, region, species) %>%
    # create binary representation here:
    group_by(time, replicate, parameterization, model, region) %>%
    summarise(presence=list(species[pres==1]), .groups="drop")
  # create a list with the number of elements = unique(dat$time), containing
  # "presence" for each time step; used to calculate Jaccard distance below
  tabTime <- list()
  times <- dat %>% pull(time) %>% unique %>% sort
  for (t in 1:length(times)){
    tabTime[[t]] <- dat %>% filter(time==times[t]) %>% pull(presence)
  }
  # calculate Jaccard's distance: 1 - length(union(a,b))/length(intersect(a,b))
  jacdist <- list()
  for (t in 1:length(times)) {
    jacdist[[t]] <- rep(0, length(tabTime[[t]]))
    for (comm in 1:length(tabTime[[t]])) {
      intersct <- intersect(tabTime[[1]][[comm]], tabTime[[t]][[comm]])
      uni <- union(tabTime[[1]][[comm]], tabTime[[t]][[comm]])
      jacdist[[t]][comm] <- 1 - length(intersct)/length(uni)
    }
  }
  dat %>%
    mutate(jaccard=unlist(jacdist)) %>% # unlist distances & put them into data
    # obtain mean Jaccard distance over the variables below:
    group_by(time, parameterization, model, region) %>%
    summarise(jaccard=mean(jaccard), .groups="drop") %>%
    ggplot() + # create plot
    aes(x=time, y=jaccard, color=region, fill=region) +
    # points for the Jaccard distances in time:
    geom_point(alpha=0.8, size=1) +
    # connect them by a light dashed line (for visual aid):
    geom_line(linetype="dashed", alpha=0.7) +
    # vertical dotted line to show where climate change ends in time:
    geom_vline(xintercept=300, linetype="dotted") +
    scale_x_continuous(name="time") +
    scale_y_continuous(name="Jaccard distance", limits=c(0, 1),
                       labels=scales::percent) +
    scale_colour_manual(values=c("#56B4E9", "#009E73", "#E69F00"), name="") +
    scale_fill_manual(values=c("#56B4E9", "#009E73", "#E69F00"), name="") +
    facet_grid(parameterization~model) +
    theme_bw() +
    theme(legend.position="bottom") %>%
    return()
}

# plot the rank-abundance curve at a given moment in time, for each model setup
# and parameterization
# Input
# - dat: a data frame like the one generated by ecoevo_main.R
# - level: whether plot is for "resource" or "consumer" species (or "all")
# - moment: time at which rank-abundance curve(s) should be plotted
# Output
# - a ggplot2 figure
plot_rac <- function(dat, level="resource", moment=2500) {
  trophic_level(dat, level) %>%
    filter(time==moment) %>%
    group_by(species, parameterization, model, replicate) %>%
    summarise(abundance=sum(n), .groups="drop_last") %>%
    summarise(abundance=mean(abundance), .groups="drop") %>%
    mutate(species=reorder(species,abundance)) %>%
    group_by(species, abundance) %>%
    arrange(abundance) %>%
    ungroup() %>%
    mutate(species=factor(paste(species, parameterization, model, sep="__"),
                          levels=rev(paste(species, parameterization,
                                           model, sep="__")))) %>%
    filter(abundance>=1e-4) %>%
    mutate(abundance=log10(abundance)) %>%
    ggplot(aes(species, abundance)) +
    geom_point(aes(x=species, y=abundance), na.rm=TRUE,
               shape=19, size=1, alpha=0.9) +
    facet_grid(parameterization~model, scales = "free", space = 'free') +
    scale_y_continuous(name=expression(paste(log[10]," density"))) +
    scale_x_discrete(name="abundance rank", breaks=NULL) +
    theme_bw() %>%
    return()
}

# plot the distribution of the fraction of patches occupied by species
# over replicates, for specific time points and for each model setup and
# parameterization (NOTE: this function summarizes over replicate runs -
# concatenate results from multiple model runs to display standard deviations)
# Input
# - dat: a data frame like the one generated by ecoevo_main.R
# - level: whether plot is for "resource" or "consumer" species (or "all")
# Output
# - a ggplot2 figure
plot_range <- function(dat, level="resource") {
  L <- max(dat$patch) # number of habitat patches
  trophic_level(dat, level) %>%
    # only the selected species and three species points in time:
    # start of climate change, end of climate change, and end of simulation
    filter(time %in% c(0, 300, 2500)) %>%
    # obtain no of species such that their density is over the threshold of 1e-6
    mutate(presence=(n>1e-6)*1) %>%
    # for each of these variables:
    group_by(time, species, parameterization, model, replicate) %>%
    # the range breadth is the fraction (total/L) of patches they are found in:
    summarise(breadth=sum(presence)/L, .groups="drop_last") %>%
    # obtain average and standard deviation over replicates
    summarise(mb=mean(breadth), sb=sd(breadth), .groups="drop") %>%
    ggplot() + # create plot
    aes(x=species,y=mb,colour=factor(time),fill=factor(time)) +
    # points for each species:
    geom_point(shape=19, size=1, alpha=0.9) +
    # connect them with dashed line (for visual aid):
    geom_line(linetype="dashed", alpha=0.5) +
    # draw plus/minus 1-sigma region; do not draw below 0% of patches occupied
    geom_ribbon(aes(ymin=mb-ifelse(sb>mb, mb, sb), ymax=mb+sb),
                colour=NA, alpha=0.2) +
    scale_y_continuous(name="range breadth", labels=scales::percent) +
    facet_grid(parameterization~model) +
    scale_colour_manual(values=c("#56B4E9", "#009E73", "#E69F00"), name="time") +
    scale_fill_manual(values=c("#56B4E9", "#009E73", "#E69F00"), name="time") +
    theme_bw() +
    theme(legend.position="bottom") %>%
    return()
}

# plot regional and global species richness over time, relative to the state
# at the onset of climate change, for each model setup and parameterization
# Input
# - dat: a data frame like the one generated by ecoevo_main.R
# - level: whether plot is for "resource" or "consumer" species (or "all")
# Output
# - a ggplot2 figure
plot_richness <- function(dat, level="resource") {
  dat <- trophic_level(dat, level)
  tab <- dat %>%
    # presence=1 if species' density > than a threshold of 1e-6; otherwise 0:
    mutate(presence=(n>1e-6)*1) %>%
    group_by(time, parameterization, model, region, replicate, species) %>%
    # sum of presence/absence = total number of species:
    summarise(presence=(sum(presence)!=0)*1, .groups="drop_last") %>%
    # species richness = sum of presences over the regions:
    summarise(rich=sum(presence), .groups="drop_last") %>%
    # take average over replicates:
    summarise(rich=mean(rich), .groups="drop") %>%
    # column for richness at the onset of climate change for every time point:
    left_join(filter(., time==0) %>% select(-time) %>% rename(init_rich=rich),
              by=c("parameterization", "model", "region")) %>%
    # obtain % of richness change compared to richness at time = 0:
    mutate(rich=rich/init_rich-1)
  # create table for global richness (as above, but without grouping by region):
  tab_tot <- dat %>%
    mutate(presence=(n>1e-6)*1) %>%
    group_by(time, parameterization, model, replicate, species) %>%
    summarise(presence=(sum(presence)!=0)*1, .groups="drop_last") %>%
    summarise(rich=sum(presence), .groups="drop_last") %>%
    summarise(rich=mean(rich), .groups="drop") %>%
    left_join(filter(., time==0) %>% select(-time) %>% rename(init_rich=rich),
              by=c("parameterization", "model")) %>%
    mutate(region="global") %>%
    # obtain % of richness change compared to richness at time = 0:
    mutate(rich=rich/init_rich-1)
  ggplot(tab) + # create plot
    # points for regional richness through time:
    geom_point(aes(x=time, y=rich, colour=as.factor(region)),
               shape=19, size=1, alpha=0.5) +
    # connect them with dashed line (for visual aid):
    geom_line(aes(x=time, y=rich, colour=as.factor(region)),
              linetype="dashed", alpha=0.5) +
    # points for global richness through time:
    geom_point(data=tab_tot, aes(x=time, y=rich, colour=as.factor(region)),
               shape=19, size=1, alpha=0.5) +
    # connect them with dashed line too (for visual aid):
    geom_line(data=tab_tot, aes(x=time, y=rich, colour=as.factor(region)),
              linetype="dashed", alpha=0.5) +
    # vertical dotted line to show where climate change ends in time:
    geom_vline(xintercept=300, linetype="dotted") +
    # horizontal dotted line showing the line of no change in richness:
    geom_hline(yintercept=0, linetype="dotted") +
    scale_x_continuous(name="time") +
    scale_y_continuous(name="% change in species richness",
                       labels=scales::percent) +
    scale_colour_manual(values=c("black", "#56B4E9", "#009E73", "#E69F00"),
                        name="") +
    facet_grid(parameterization~model) +
    theme_bw() +
    theme(legend.position="bottom") %>%
    return()
}

# show densities across the landscape through time; works for data with
# a single model and parameterization
# Input
# - dat: a data frame like the one generated by ecoevo_main.R
# Output
# - a ggplot2 figure
plot_timeseries <- function(dat) {
  # define color gradient from cold to warm colors:
  color_pal <- colorRampPalette(c("#56B4E9", "#009E73", "#E69F00"))
  S <- filter(dat, tl=="R") %>% pull(species) %>% max() # no. of resource spp.
  dat %>%
    # calculate mean densities at each time and patch for each species:
    group_by(time, species, patch, tl) %>%
    summarise(avg_n=mean(n), .groups="drop") %>%
    mutate(species=ifelse(tl=="C", species-S, species)) %>%
    mutate(species=as.factor(species),
           tl=ifelse(tl=="R", "resource species", "consumer species")) %>%
    ggplot() + # create plot
    aes(x=patch, ymin=0, y=avg_n ,ymax=avg_n, colour=species, fill=species) +
    geom_ribbon(alpha=0.3) +
    # panel rows: trophic level; panel columns: time
    facet_grid(tl~time, labeller=label_bquote(row=.(tl), col=t==.(time))) +
    coord_flip() +
    scale_x_reverse(name="habitat patch number", expand=c(0.02, 0.02)) +
    scale_y_continuous(name="density", labels=abbreviate) +
    scale_colour_manual(values=color_pal(S)) +
    scale_fill_manual(values=color_pal(S)) +
    theme_bw() +
    theme(legend.position="none") %>%
    return()
}

# show community average trait lag against community average trait dispersion
# (NOTE: there will be as many points displayed as the number of different
# community runs the input data frame "dat" contains - oncatenate results from
# multiple model runs to display each as a point)
# Input
# - dat: a data frame like the one generated by ecoevo_main.R
# Output
# - a ggplot2 figure
plot_traitlag <- function(dat) {
  smoothstp <- function(n) { # smoothed step function (vectorized)
    return(ifelse(n<1, (1*(n>0))*(n*n*n*(10+n*(-15+6*n))), 1))
  }
  Tmp <- function(x, t, tE, Cmax, Cmin, Tmax, Tmin) { # local temperatures
    return((Tmax-Tmin)*x+Tmin + ((Cmin-Cmax)*x+Cmax)*smoothstp(t/tE))
  }
  dat %>%
    # filter for only resource species:
    filter(tl=="R") %>%
    # filter for times between start & end of climate change (0 <= t <= 300):
    filter(time>=0, time<=300) %>%
    # densities below 0 (due to numerical error) are set to 0:
    mutate(n=ifelse(n<=0, 0, n)) %>%
    # calculate temperatures at each patch and each point in time:
    mutate(temp=Tmp(seq(from=0, to=1, l=50)[patch], time,
                    300, 9.66, 1.26, 25, -10)) %>%
    # compute relative densities p and weighted trait means mbar in each patch:
    group_by(time, patch, replicate, model, parameterization) %>%
    mutate(p=n/sum(n), mbar=sum(p*m)) %>%
    # create nested data, with new column (data) for local community state:
    group_by(time, patch, replicate, model, parameterization, temp, mbar) %>%
    nest() %>%
    ungroup() %>%
    # obtain trait lag and trait dispersion for each patch and time point:
    mutate(traitlag=map2_dbl(temp, mbar, `-`),
           dispersion=map2_dbl(data, mbar, ~sum(.x$p*(.x$m-.y)^2)),
           richness=map_int(data, nrow)) %>% # and also local species richness
    # finally, average all these quantities over patches and time:
    group_by(replicate, model, parameterization) %>%
    summarise(traitlag=mean(traitlag), dispersion=mean(dispersion),
              richness=mean(richness), .groups="drop") %>%
    # plot results:
    ggplot() +
    aes(x=dispersion, y=traitlag, colour=parameterization) +
    geom_point(alpha=0.2) +
    scale_colour_manual(values=c("#0072B2","#999999","#E69F00","#CC79A7")) +
    stat_fit_glance(method="lm", label.x="right", label.y="top",
                    method.args=list(formula=y~x),
                    mapping=aes(label=sprintf('R^2~"="~%.3f', stat(r.squared))),
                    parse=TRUE) +
    stat_smooth(geom="line", method=lm, se=FALSE, size=1, formula=y~x) +
    facet_wrap(~model, scales="free") +
    theme_bw() %>%
    return()
}
