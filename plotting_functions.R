# plot beta diversity (gamma richness divided by alpha richness) over time,
# for each model setup and parameterization
# Input
# - dat: a data frame like the one generated by ecoevo_main.R
# - level: whether plot is for "resource" or "consumer" species (or "all")
# Output
# - a ggplot2 figure
plot_betadiv <- function(dat, level="resource") {
  if (level=="resource") { # if we are interested in just the resource species:
    dat <- dat %>% filter(tl=="R") # filter for only resources
  }
  if (level=="consumer") { # if we want just consumers:
    dat <- dat %>% filter(tl=="C") # filter for consumers
  } # otherwise, consider all species together
  # obtain local (alpha) diversity
  alpha <- dat %>%
    group_by(time, patch, parameterization, replicate, model) %>%
    summarise(richness=sum(1*(n>1e-6))) %>%
    ungroup() %>%
    group_by(time, patch, parameterization, model) %>%
    summarise(meanrich=mean(richness)) %>%
    ungroup() %>%
    group_by(time, parameterization, model) %>%
    summarise(localrich=mean(meanrich)) %>%
    ungroup()
  # obtain global (gamma) diversity
  gamma <- dat %>%
    mutate(presence=(n!=0)*1) %>%
    group_by(time, species, parameterization, replicate, model) %>%
    summarise(presence=(sum(presence)!=0)*1) %>%
    ungroup() %>%
    group_by(time, parameterization, replicate, model) %>%
    summarise(rich=sum(presence)) %>%
    ungroup() %>%
    group_by(time, parameterization, model) %>%
    summarise(globalrich=mean(rich)) %>%
    ungroup()
  # obtain beta diversity
  beta <- left_join(gamma, alpha, by=c("time", "model", "parameterization")) %>%
    mutate(beta_diversity=(globalrich/localrich))
  p <- ggplot(beta) +
    geom_point(aes(x=time, y=beta_diversity),
               colour="#0072B2", shape=19, size=1, alpha=0.7) +
    geom_line(aes(x=time, y=beta_diversity),
              colour="#0072B2", linetype="dashed", alpha=0.5) +
    geom_vline(xintercept=300, linetype="dotted") +
    scale_x_continuous(name="time") +
    scale_y_continuous(name="beta diversity") +
    facet_grid(parameterization~model) +
    theme_bw() +
    theme(legend.position="bottom")
  return(p)
}

# plot the distribution of local species richnesses over time, for each
# model setup and parameterization
# Input
# - dat: a data frame like the one generated by ecoevo_main.R
# - level: whether plot is for "resource" or "consumer" species (or "all")
# Output
# - a ggplot2 figure
plot_diversity <- function(dat, level="resource") {
  if (level=="resource") { # if we are interested in just the resource species:
    dat <- dat %>% filter(tl=="R") # filter for only resources
  }
  if (level=="consumer") { # if we want just consumers:
    dat <- dat %>% filter(tl=="C") # filter for consumers
  } # otherwise, consider all species together
  p <- dat %>% # start data manipulation
    # for each of these variables:
    group_by(time, patch, parameterization, replicate, model) %>%
    # obtain no of species such that their density is over the threshold of 1e-6
    summarise(H=sum(1*(n>1e-6))) %>%
    ungroup() %>%
    # now average these results over replicates:
    group_by(time, patch, parameterization, model) %>%
    summarise(meanH=mean(H)) %>%
    ungroup() %>%
    # and finally, obtain the mean and standard deviation across the L patches:
    group_by(time, parameterization, model) %>%
    summarise(mH=mean(meanH), sH=sd(meanH)) %>%
    ggplot() + # start plotting
    # points for the mean richness at each point in time:
    geom_point(aes(x=time,y=mH), colour="#0072B2", shape=19, size=1, alpha=0.7) +
    # connect them by a light dashed line (for visual aid):
    geom_line(aes(x=time,y=mH), colour="#0072B2", linetype="dashed", alpha=0.5) +
    # show plus/minus 1-sigma region around the mean:
    geom_ribbon(aes(x=time, ymin=mH-sH, ymax=mH+sH),
                colour=NA, fill="#0072B2", alpha=0.3) +
    # vertical dotted line to show where climate change ends in time:
    geom_vline(xintercept=300, linetype="dotted") +
    scale_x_continuous(name="time") +
    scale_y_continuous(name="species richness") +
    facet_grid(parameterization~model) +
    theme_bw() +
    theme(legend.position="bottom")
  return(p)
}

# plot the Jaccard distance of regional communities from their state at the
# onset of climate change over time, for each model setup and parameterization
# Input
# - dat: a data frame like the one generated by ecoevo_main.R
# - level: whether plot is for "resource" or "consumer" species (or "all")
# Output
# - a ggplot2 figure
plot_jaccard <- function(dat, level="resource") {
  if (level=="resource") { # if we are interested in just the resource species:
    dat <- dat %>% filter(tl=="R") # filter for only resources
  }
  if (level=="consumer") { # if we want just consumers:
    dat <- dat %>% filter(tl=="C") # filter for consumers
  } # otherwise, consider all species together
  # new column "presence" representing the species present in every patch in
  # binary: if species are represented by 01111111 (all species present in
  # that patch except the first species), this "binary presence" will be 127
  dat <- dat %>%
    # presence=1 if species' density > than a threshold of 1e-6; otherwise 0
    mutate(presence=(n>1e-6)*1) %>%
    # for all parameters below:
    group_by(time, species, replicate, parameterization, model, region) %>%
    # get total number of persisting species:
    summarise(pres=(sum(presence)>0)*1) %>%
    ungroup() %>%
    arrange(time, parameterization, model, replicate, region, species) %>%
    # create binary representation here:
    group_by(time, replicate, parameterization, model, region) %>%
    summarise(presence=list(species[pres==1])) %>%
    ungroup()
  # create a list with the number of elements = unique(dat$time), containing
  # "presence" for each time step; used to calculate Jaccard distance below
  tabTime <- list()
  times <- dat %>% pull(time) %>% unique %>% sort
  for (t in 1:length(times)){
    tabTime[[t]] <- dat %>% filter(time==times[t]) %>% pull(presence)
  }
  # perform calculation of Jaccard's distance:
  # 1 - length(union(a,b)/length(intersect(a,b))
  jacdist <- list()
  for (t in 1:length(times)) {
    jacdist[[t]] <- rep(0, length(tabTime[[t]]))
    for (comm in 1:length(tabTime[[t]])) {
      intersct <- intersect(tabTime[[1]][[comm]], tabTime[[t]][[comm]])
      uni <- union(tabTime[[1]][[comm]], tabTime[[t]][[comm]])
      jacdist[[t]][comm] <- 1 - length(intersct)/length(uni)
    }
  }
  p <- dat %>%
    mutate(jaccard=unlist(jacdist)) %>% # unlist distances & put them into data
    # obtain mean Jaccard distance over the variables below:
    group_by(time, parameterization, model, region) %>%
    summarise(jaccard=mean(jaccard)) %>%
    ungroup() %>%
    ggplot() + # create plot
    aes(x=time, y=jaccard, color=region, fill=region) +
    # points for the Jaccard distances in time:
    geom_point(alpha=0.8, size=1) +
    # connect them by a light dashed line (for visual aid):
    geom_line(linetype="dashed", alpha=0.7) +
    # vertical dotted line to show where climate change ends in time:
    geom_vline(xintercept=300, linetype="dotted") +
    scale_x_continuous(name="time") +
    scale_y_continuous(name="Jaccard distance", limits=c(0, 1),
                       labels=scales::percent) +
    scale_colour_manual(values=c("#56B4E9", "#009E73", "#E69F00"), name="") +
    scale_fill_manual(values=c("#56B4E9", "#009E73", "#E69F00"), name="") +
    facet_grid(parameterization~model) +
    theme_bw() +
    theme(legend.position="bottom")
  return(p)
}

# Plot the rank-abundance curve at a given moment in time, for each model setup
# and parameterization.
# Input
# - dat: a data frame like the one generated by ecoevo_main.R
# - level: whether plot is for "resource" or "consumer" species (or "all")
# - moment: time at which rank-abundance curve(s) should be plotted
# Output
# - a ggplot2 figure
plot_rac <- function(dat, level="resource", moment=2500) {
  if (level=="resource") { # if we are interested in just the resource species:
    dat <- dat %>% filter(tl=="R") # filter for only resources
  }
  if (level=="consumer") { # if we want just consumers:
    dat <- dat %>% filter(tl=="C") # filter for consumers
  } # otherwise, consider all species together
  S <- max(dat$species)
  p <- dat %>%
    filter(time==moment) %>%
    group_by(species, parameterization, replicate, model) %>%
    summarise(abundance=sum(n)) %>%
    ungroup() %>%
    group_by(species, parameterization, model) %>%
    summarise(abundance=mean(abundance)) %>%
    ungroup() %>%
    mutate(species=reorder(species,abundance)) %>%
    group_by(species, abundance) %>%
    arrange(abundance) %>%
    ungroup() %>%
    mutate(species=factor(paste(species, parameterization, model, sep="__"),
                          levels=rev(paste(species, parameterization,
                                           model, sep="__")))) %>%
    filter(abundance>=1e-4) %>%
    mutate(abundance=log10(abundance)) %>%
    ggplot(aes(species, abundance)) +
    geom_point(aes(x=species, y=abundance), na.rm=TRUE,
               shape=19, size=1, alpha=0.9) +
    facet_grid(parameterization~model, scales = "free", space = 'free') +
    scale_y_continuous(name=expression(paste(log[10]," density"))) +
    scale_x_discrete(name="abundance rank", breaks=NULL) +
    theme_bw()
    return(p)
}

# Plot the distribution of the fraction of patches occupied by species
# over replicates, for specific time points and for each model setup and
# parameterization. NOTE: this function summarizes over replicate runs.
# Concatenate results from multiple model runs to display standard deviations.
# Input
# - dat: a data frame like the one generated by ecoevo_main.R
# - level: whether plot is for "resource" or "consumer" species (or "all")
# Output
# - a ggplot2 figure
plot_range <- function(dat, level="resource") {
  if (level=="resource") { # if we are interested in just the resource species:
    dat <- dat %>% filter(tl=="R") # filter for only resources
  }
  if (level=="consumer") { # if we want just consumers:
    dat <- dat %>% filter(tl=="C") # filter for consumers
  } # otherwise, consider all species together
  L <- max(dat$patch) # number of habitat patches
  dat <- dat %>%
    # only the selected species and three species points in time:
    # start of climate change, end of climate change, and end of simulation
    filter(time %in% c(0, 300, 2500)) %>%
    # obtain no of species such that their density is over the threshold of 1e-6
    mutate(presence=(n>1e-6)*1) %>%
    # for each of these variables:
    group_by(time, species, parameterization, replicate, model) %>%
    # the range breadth is the fraction (total/L) of patches they are found in:
    summarise(breadth=sum(presence)/L) %>%
    ungroup() %>%
    # obtain average and standard deviation over replicates
    group_by(time, species, parameterization, model) %>%
    summarise(mb=mean(breadth), sb=sd(breadth)) %>%
    ungroup()
  p <- dat %>%
    ggplot() + # create plot
    aes(x=species,y=mb,colour=factor(time),fill=factor(time)) +
    # points for each species:
    geom_point(shape=19, size=1, alpha=0.9) +
    # connect them with dashed line (for visual aid):
    geom_line(linetype="dashed", alpha=0.5) +
    # draw plus/minus 1-sigma region; do not draw below 0% of patches occupied
    geom_ribbon(aes(ymin=mb-ifelse(sb>mb, mb, sb), ymax=mb+sb),
                colour=NA, alpha=0.2) +
    scale_y_continuous(name="range breadth", labels=scales::percent) +
    facet_grid(parameterization~model) +
    scale_colour_manual(values=c("#56B4E9", "#009E73", "#E69F00"), name="time") +
    scale_fill_manual(values=c("#56B4E9", "#009E73", "#E69F00"), name="time") +
    theme_bw() +
    theme(legend.position="bottom")
  return(p)
}

# plot regional and global species richness over time, relative to the state
# at the onset of climate change, for each model setup and parameterization
# Input
# - dat: a data frame like the one generated by ecoevo_main.R
# - level: whether plot is for "resource" or "consumer" species (or "all")
# Output
# - a ggplot2 figure
plot_richness <- function(dat, level="resource") {
  if (level=="resource") { # if we are interested in just the resource species:
    dat <- dat %>% filter(tl=="R") # filter for only resources
  }
  if (level=="consumer") { # if we want just consumers:
    dat <- dat %>% filter(tl=="C") # filter for consumers
  } # otherwise, consider all species together
  tab <- dat %>%
    # presence=1 if species' density > than a threshold of 1e-6; otherwise 0:
    mutate(presence=(n>1e-6)*1) %>%
    group_by(time, species, parameterization, replicate, model, region) %>%
    # sum of presence/absence = total number of species:
    summarise(presence=(sum(presence)!=0)*1) %>%
    ungroup() %>%
    group_by(time, parameterization, replicate, model, region) %>%
    # species richness = sum of presences over the regions:
    summarise(rich=sum(presence)) %>%
    ungroup() %>%
    # take average over replicates:
    group_by(time, parameterization, model, region) %>%
    summarise(rich=mean(rich)) %>%
    ungroup()
  # create table for global richness; calculation as above, but
  # without grouping the data by region
  tab_tot <- dat %>%
    mutate(presence=(n!=0)*1) %>%
    group_by(time, species, parameterization, replicate, model) %>%
    summarise(presence=(sum(presence)!=0)*1) %>%
    ungroup() %>%
    group_by(time, parameterization, replicate, model) %>%
    summarise(rich=sum(presence)) %>%
    ungroup() %>%
    group_by(time, parameterization, model) %>%
    summarise(rich=mean(rich)) %>%
    ungroup() %>%
    mutate(region="global")
  # normalize the species richness data, comparing it with richness
  # at the onset of climate change
  for (scen in unique(dat$parameterization)) { # first do so regionally
    for (struc in unique(dat$model)) {
      for (reg in unique(dat$region)) {
        tab$rich[(tab$parameterization==scen)&(tab$model==struc)&
                   (tab$region==reg)] <-
          tab$rich[(tab$parameterization==scen)&(tab$model==struc)&
                     (tab$region==reg)] /
          tab$rich[(tab$parameterization==scen)&(tab$model==struc)&
                     (tab$region==reg)][1] - 1
      }
      tab_tot$rich[(tab_tot$parameterization==scen)& # then globally
                     (tab_tot$model==struc)] <-
        tab_tot$rich[(tab_tot$parameterization==scen)&
                       (tab_tot$model==struc)] /
        tab_tot$rich[(tab_tot$parameterization==scen)&
                       (tab_tot$model==struc)][1] - 1
    }
  }
  p <- ggplot(tab) + # create plot
    # points for regional richness through time:
    geom_point(aes(x=time, y=rich, colour=as.factor(region)),
               shape=19, size=1, alpha=0.5) +
    # connect them with dashed line (for visual aid):
    geom_line(aes(x=time, y=rich, colour=as.factor(region)),
              linetype="dashed", alpha=0.5) +
    # points for global richness through time:
    geom_point(data=tab_tot, aes(x=time, y=rich, colour=as.factor(region)),
               shape=19, size=1, alpha=0.5) +
    # connect them with dashed line too (for visual aid):
    geom_line(data=tab_tot, aes(x=time, y=rich, colour=as.factor(region)),
              linetype="dashed", alpha=0.5) +
    # vertical dotted line to show where climate change ends in time:
    geom_vline(xintercept=300, linetype="dotted") +
    # horizontal dotted line showing the line of no change in richness:
    geom_hline(yintercept=0, linetype="dotted") +
    scale_x_continuous(name="time") +
    scale_y_continuous(name="% change in species richness",
                       labels=scales::percent) +
    scale_colour_manual(values=c("black", "#56B4E9", "#009E73", "#E69F00"),
                        name="") +
    facet_grid(parameterization~model) +
    theme_bw() +
    theme(legend.position="bottom")
  return(p)
}

# show densities across the landscape through time; works for data with
# a single model and parameterization
# Input
# - dat: a data frame like the one generated by ecoevo_main.R
# Output
# - a ggplot2 figure
plot_timeseries <- function(dat) {
  # define color gradient from cold to warm colors:
  color_pal <- colorRampPalette(c("#56B4E9", "#009E73", "#E69F00"))
  S <- dat %>% filter(tl=="R") %>% pull(species) %>% max # no. of resource spp.
  p <- dat %>%
    # calculate mean densities at each time and patch for each species:
    group_by(time, species, patch, tl) %>%
    summarise(avg_n=mean(n)) %>%
    ungroup() %>%
    mutate(species=ifelse(tl=="C", species-S, species)) %>%
    mutate(species=as.factor(species),
           tl=ifelse(tl=="R", "resource species", "consumer species")) %>%
    ggplot() + # create plot
    aes(x=patch, ymin=0, y=avg_n ,ymax=avg_n, colour=species, fill=species) +
    geom_ribbon(alpha=0.3) +
    # panel rows: trophic level; panel columns: time
    facet_grid(tl~time, labeller=label_bquote(row=.(tl), col=t==.(time))) +
    coord_flip() +
    scale_x_reverse(name="habitat patch number", expand=c(0.02, 0.02)) +
    scale_y_continuous(name="density", labels=abbreviate) +
    scale_colour_manual(values=color_pal(S)) +
    scale_fill_manual(values=color_pal(S)) +
    theme_bw() +
    theme(legend.position="none")
  return(p)
}

# show community average trait lag against community average trait dispersion
# NOTE: there will be as many points displayed as the number of different
# community runs the input data frame "dat" contains. Concatenate results from
# multiple model runs to display each as a point.
# Input
# - dat: a data frame like the one generated by ecoevo_main.R
# - level: whether plot is for "resource" or "consumer" species
# Output
# - a ggplot2 figure
plot_traitlag <- function(dat, level="resource") {
  if (level=="resource") { # if we are interested in just the resource species:
    dat <- dat %>% filter(tl=="R") # filter for only resources
  } else { # otherwise filter for just consumers
    dat <- dat %>% filter(tl=="C")
  }
  smoothstp <- function(n) { # smoothed step function (vectorized)
    return(ifelse(n<1, (1*(n>0))*(n*n*n*(10+n*(-15+6*n))), 1))
  }
  Tmp <- function(x, t, tE, Cmax, Cmin, Tmax, Tmin) { # local temperatures
    return((Tmax-Tmin)*x+Tmin + ((Cmin-Cmax)*x+Cmax)*smoothstp(t/tE))
  }
  p <- dat %>%
    # filter for times between start & end of climate change (0 <= t <= 300):
    filter(time>=0, time<=300) %>%
    # densities below 0 (due to numerical error) are set to 0:
    mutate(n=ifelse(n<=0, 0, n)) %>%
    # join the vbar and dbar columns into one column:
    mutate(parameterization=paste0("vbar=", vbar, ", dbar=", dbar)) %>%
    # calculate temperatures at each patch and each point in time:
    mutate(temp=Tmp(seq(from=0, to=1, l=50)[patch], time,
                    300, 9.66, 1.26, 25, -10)) %>%
    # compute relative densities over whole landscape:
    group_by(time, replicate, parameterization, model) %>%
    mutate(reldens=n/sum(n)) %>%
    ungroup() %>%
    # obtain trait lag A and trait dispersion V for each patch and time point:
    group_by(time, patch, replicate, parameterization, model) %>%
    summarise(A=mean(reldens*(m-temp)^2), # trait lag
              mbar=mean(reldens*m), # weighted mean temperature optimum
              V=mean(reldens*(m-mbar)^2)) %>% # trait dispersion
    ungroup() %>%
    # average them over patches and time:
    group_by(replicate, parameterization, model) %>%
    summarise(mA=mean(A), mV=mean(V)) %>%
    ungroup() %>%
    # plot results:
    ggplot() +
    aes(x=mV, y=mA, colour=model, shape=parameterization) +
    geom_point(alpha=0.5) +
    xlab("Weighted community average mean trait dispersion") +
    ylab("Weighted community-average trait lag") +
    theme_bw()
  return(p)
}
